MODULE DISTRIBUTED_VECTORS_MIX
USE PARKIND1, ONLY : JPRB
USE YOMHOOK , ONLY : LHOOK, DR_HOOK

!     ------------------------------------------------------------------

!*    Distributed storage for one-dimensional arrays

!     This module provides the following:

!       - The derived type "distributed_vector".
!       - Subroutines "allocate_vector" and "deallocate_vector".
!       - Access to the part of the vector held on the local PE.
!       - Overloaded assignment and arithmetic operators which
!         implicitly translate between normal 1d arrays and
!         distributed_vectors.
!       - A distributed version of DOT_PRODUCT.

!         A "distributed_vector" acts like a pointer to a real
!         one-dimensional array. Unlike an array pointer, you cannot
!         access individual elements.

!         It is vital that any operation involving a
!         "distributed_vector" is performed by all PEs. (In general
!         routines which use "distributed_vector"s will execute
!         identical code on all PEs. All message passing is done
!         implicitly via the module suroutines below.)

!  The following routines must be used to allocate and deallocate
!  space on each PE for each distributed_vector.

!         allocate_vector (handle,klen) allocates storage for the
!                                       distributed_vector "handle"
!                                       which can be used to store a
!                                       on dimensional array of "klen"
!                                       elements.

!         deallocate_vector (handle)    deallocates the space associated
!                                       with "handle".

! The following operations are defined, where handle, handle1 and
! handle2 represent distributed vectors (allocted with identical
! values for "klen"); pvec, pvec1 and pvec2 are 1d arrays with
! SHAPE "1:klen" or with SIZE "1+handle%local_end-handle%local_end";
! OP is one of +,-,*,/,** or =; and scalar is a real scalar.

!         handle  OP pvec(:)
!         pvec(:) OP handle
!         handle1 OP handle2
!         handle  OP scalar

!         scalar = DOT_PRODUCT (handle,pvec)
!         scalar = DOT_PRODUCT (handle1,handle2)
!         scalar = DOT_PRODUCT (pvec,handle2)

!   Externals.
!   ----------
!       MPL_SEND
!       MPL_RECV
!       ABOR1

!   Reference.
!   ----------
!       None yet!

!   Author.
!   -------
!       Mike Fisher *ECMWF*

!   Modifications.
!   --------------
!       Original   97-11-26
!       D.Dent     00-09-01  MPE to MPL conversion

!     ------------------------------------------------------------------



USE PARKIND1  ,ONLY : JPIM     ,JPRB

USE MPL_MODULE

IMPLICIT NONE

PRIVATE
PUBLIC  DISTRIBUTED_VECTOR, ALLOCATE_VECTOR, DEALLOCATE_VECTOR,&
        &NDV_CHUNK_SIZE, ASSIGNMENT(=), OPERATOR(+), OPERATOR(-),&
        &OPERATOR(*), OPERATOR(/), OPERATOR(**), DOT_PRODUCT,&
        &DVSECTION,&
        &SUM,MAXVAL,SQRT,SETUP_DISTVEC,SCATTER_VECTOR,GATHER_VECTOR

INTEGER(KIND=JPIM) :: NDV_CHUNK_SIZE
INTEGER(KIND=JPIM) :: NPROC,MYPROC,MINTET,MREALT,MT_DISTRIBUTED_VECTOR
INTEGER(KIND=JPIM) ,ALLOCATABLE :: NPRCIDS(:)
INTEGER(KIND=JPIM),PARAMETER :: JPSETUP=77777

TYPE DISTRIBUTED_VECTOR
REAL(KIND=JPRB), POINTER :: LOCAL(:)
INTEGER(KIND=JPIM)       :: GLOBAL_LENGTH,LOCAL_START,LOCAL_END,NCHNKS
INTEGER(KIND=JPIM)       :: MSETUP
END TYPE DISTRIBUTED_VECTOR

INTERFACE ASSIGNMENT (=)
MODULE PROCEDURE ASSIGN_AR_DV, ASSIGN_DV_AR,ASSIGN_DV_DV, ASSIGN_SCALAR_DV
END INTERFACE

INTERFACE OPERATOR (*)
MODULE PROCEDURE MULTIPLY_AR_DV, MULTIPLY_DV_AR,&
                   &MULTIPLY_DV_DV, MULTIPLY_SCALAR_DV,&
                   &MULTIPLY_DV_SCALAR
END INTERFACE

INTERFACE OPERATOR (+)
MODULE PROCEDURE ADD_AR_DV, ADD_DV_AR,&
                   &ADD_DV_DV, ADD_SCALAR_DV,&
                   &ADD_DV_SCALAR
END INTERFACE

INTERFACE OPERATOR (-)
MODULE PROCEDURE SUBTRACT_AR_DV, SUBTRACT_DV_AR,&
                   &SUBTRACT_DV_DV, SUBTRACT_SCALAR_DV,&
                   &SUBTRACT_DV_SCALAR, NEGATE_DV
END INTERFACE

INTERFACE OPERATOR (/)
MODULE PROCEDURE DIVIDE_AR_DV, DIVIDE_DV_AR,&
                   &DIVIDE_DV_DV, DIVIDE_SCALAR_DV,&
                   &DIVIDE_DV_SCALAR
END INTERFACE

INTERFACE OPERATOR (**)
MODULE PROCEDURE POWER_AR_DV, POWER_DV_AR,&
                   &POWER_DV_DV, POWER_SCALAR_DV,&
                   &POWER_DV_SCALAR
END INTERFACE

INTERFACE DOT_PRODUCT
MODULE PROCEDURE DOT_PRODUCT_DV_DV, DOT_PRODUCT_DV_AR,DOT_PRODUCT_AR_DV
END INTERFACE

INTERFACE SCATTER_VECTOR
MODULE PROCEDURE SCATTER_VECTOR_DV, SCATTER_VECTOR_AR
END INTERFACE

INTERFACE SUM
MODULE PROCEDURE SUM_DV
END INTERFACE

INTERFACE MAXVAL
MODULE PROCEDURE MAXVAL_DV
END INTERFACE

INTERFACE SQRT
MODULE PROCEDURE SQRT_DV
END INTERFACE

! module procedures:

CONTAINS
SUBROUTINE SETUP_DISTVEC(KPROC,KYPROC,KINTET,KREALT,KTAG,&
   &KDV_CHUNK_SIZE,KPRCIDS)
INTEGER(KIND=JPIM) :: KPROC,KYPROC,KINTET,KREALT,KTAG,KDV_CHUNK_SIZE
INTEGER(KIND=JPIM) :: KPRCIDS(KPROC)
REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:SETUP_DISTVEC',0,ZHOOK_HANDLE)
ALLOCATE(NPRCIDS(KPROC))
NPROC=KPROC
MYPROC=KYPROC
MINTET=KINTET
MREALT=KREALT
MT_DISTRIBUTED_VECTOR=KTAG
NDV_CHUNK_SIZE=KDV_CHUNK_SIZE
NPRCIDS(:)=KPRCIDS(:)

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:SETUP_DISTVEC',1,ZHOOK_HANDLE)
END SUBROUTINE SETUP_DISTVEC

INTEGER(KIND=JPIM) FUNCTION NCHUNKS (KLEN)
INTEGER(KIND=JPIM), INTENT(IN) :: KLEN
REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:NCHUNKS',0,ZHOOK_HANDLE)
NCHUNKS = (KLEN+NDV_CHUNK_SIZE-1)/NDV_CHUNK_SIZE

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:NCHUNKS',1,ZHOOK_HANDLE)
END FUNCTION NCHUNKS

INTEGER(KIND=JPIM) FUNCTION JEND (KPROC,KLEN)
INTEGER(KIND=JPIM), INTENT(IN) :: KPROC,KLEN
REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:JEND',0,ZHOOK_HANDLE)
JEND = MIN(  NDV_CHUNK_SIZE &
                &*NINT( REAL(KPROC)&
                      &*(REAL(NCHUNKS(KLEN))/REAL(NPROC)))&
               &,KLEN)

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:JEND',1,ZHOOK_HANDLE)
END FUNCTION JEND

INTEGER(KIND=JPIM) FUNCTION JSTART (KPROC,KLEN)
INTEGER(KIND=JPIM), INTENT(IN) :: KPROC,KLEN
REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:JSTART',0,ZHOOK_HANDLE)
JSTART = 1+JEND(KPROC-1,KLEN)

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:JSTART',1,ZHOOK_HANDLE)
END FUNCTION JSTART

SUBROUTINE ALLOCATE_VECTOR (HANDLE,KLEN)

!         allocate storage for the distributed vector

TYPE (DISTRIBUTED_VECTOR), INTENT(OUT) :: HANDLE
INTEGER(KIND=JPIM), INTENT(IN)  :: KLEN

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:ALLOCATE_VECTOR',0,ZHOOK_HANDLE)
IF(NCHUNKS(KLEN) < NPROC) CALL ABOR1&
 & ('ALLOCATE_VECTOR : NCHUNKS<NPROC, REDUCE CHUNK SIZE!')
  
HANDLE%GLOBAL_LENGTH = KLEN
HANDLE%LOCAL_START   = JSTART(MYPROC,KLEN)
HANDLE%LOCAL_END     = JEND  (MYPROC,KLEN)
HANDLE%NCHNKS  = NCHUNKS(KLEN)
HANDLE%MSETUP = JPSETUP

ALLOCATE (HANDLE%LOCAL(HANDLE%LOCAL_START:HANDLE%LOCAL_END))

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:ALLOCATE_VECTOR',1,ZHOOK_HANDLE)
END SUBROUTINE ALLOCATE_VECTOR

SUBROUTINE DEALLOCATE_VECTOR (HANDLE)

!         deallocate storage for the distributed array

TYPE (DISTRIBUTED_VECTOR), INTENT(OUT) :: HANDLE
REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:DEALLOCATE_VECTOR',0,ZHOOK_HANDLE)
DEALLOCATE (HANDLE%LOCAL)
HANDLE%MSETUP = 0

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:DEALLOCATE_VECTOR',1,ZHOOK_HANDLE)
END SUBROUTINE DEALLOCATE_VECTOR

SUBROUTINE ASSIGN_AR_DV (HANDLE,PVEC)

!         copy array to the distributed_vector

REAL(KIND=JPRB),                      INTENT(IN)    :: PVEC(:)
TYPE (DISTRIBUTED_VECTOR), INTENT(INOUT) :: HANDLE

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:ASSIGN_AR_DV',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP)&
     &CALL ABOR1 ('error: store to unallocated distributed_vector')

IF (SIZE(PVEC) == SIZE(HANDLE%LOCAL)) THEN
  HANDLE%LOCAL(:) = PVEC(:)
ELSE IF (SIZE(PVEC) == HANDLE%GLOBAL_LENGTH) THEN
  HANDLE%LOCAL(:) = PVEC(HANDLE%LOCAL_START:HANDLE%LOCAL_END)
ELSE
  CALL ABOR1 ('error: distributed_vector size mismatch')
ENDIF

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:ASSIGN_AR_DV',1,ZHOOK_HANDLE)
END SUBROUTINE ASSIGN_AR_DV

FUNCTION MULTIPLY_AR_DV (PVEC,HANDLE)

!         multiply array and distributed_vector

REAL(KIND=JPRB),                      INTENT(IN) :: PVEC(:)
TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE
REAL(KIND=JPRB), DIMENSION(HANDLE%LOCAL_START:HANDLE%LOCAL_END) ::MULTIPLY_AR_DV

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:MULTIPLY_AR_DV',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP)&
     &CALL ABOR1 ('error: multiply unallocated distributed_vector')

IF (SIZE(PVEC) == SIZE(HANDLE%LOCAL)) THEN
  MULTIPLY_AR_DV = PVEC(:) * HANDLE%LOCAL(:)
ELSE IF (SIZE(PVEC) == HANDLE%GLOBAL_LENGTH) THEN
  MULTIPLY_AR_DV =&
   &PVEC(HANDLE%LOCAL_START:HANDLE%LOCAL_END)*HANDLE%LOCAL(:)
ELSE
  CALL ABOR1 ('error: distributed_vector size mismatch')
ENDIF

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:MULTIPLY_AR_DV',1,ZHOOK_HANDLE)
END FUNCTION MULTIPLY_AR_DV

FUNCTION DIVIDE_AR_DV (PVEC,HANDLE)

!         divide array and distributed_vector

REAL(KIND=JPRB),                      INTENT(IN) :: PVEC(:)
TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE
REAL(KIND=JPRB), DIMENSION(HANDLE%LOCAL_START:HANDLE%LOCAL_END) ::DIVIDE_AR_DV

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:DIVIDE_AR_DV',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP)&
     &CALL ABOR1 ('error: divide unallocated distributed_vector')

IF (SIZE(PVEC) == SIZE(HANDLE%LOCAL)) THEN
  DIVIDE_AR_DV = PVEC(:) / HANDLE%LOCAL(:)
ELSE IF (SIZE(PVEC) == HANDLE%GLOBAL_LENGTH) THEN
  DIVIDE_AR_DV =PVEC(HANDLE%LOCAL_START:HANDLE%LOCAL_END)/HANDLE%LOCAL(:)
ELSE
  CALL ABOR1 ('error: distributed_vector size mismatch')
ENDIF

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:DIVIDE_AR_DV',1,ZHOOK_HANDLE)
END FUNCTION DIVIDE_AR_DV

FUNCTION POWER_AR_DV (PVEC,HANDLE)

!         power array and distributed_vector

REAL(KIND=JPRB),                      INTENT(IN) :: PVEC(:)
TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE
REAL(KIND=JPRB), DIMENSION(HANDLE%LOCAL_START:HANDLE%LOCAL_END) ::POWER_AR_DV

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:POWER_AR_DV',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP)&
     &CALL ABOR1 ('error: power unallocated distributed_vector')

IF (SIZE(PVEC) == SIZE(HANDLE%LOCAL)) THEN
  POWER_AR_DV = PVEC(:) ** HANDLE%LOCAL(:)
ELSE IF (SIZE(PVEC) == HANDLE%GLOBAL_LENGTH) THEN
  POWER_AR_DV =PVEC(HANDLE%LOCAL_START:HANDLE%LOCAL_END)**HANDLE%LOCAL(:)
ELSE
  CALL ABOR1 ('error: distributed_vector size mismatch')
ENDIF

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:POWER_AR_DV',1,ZHOOK_HANDLE)
END FUNCTION POWER_AR_DV

FUNCTION ADD_AR_DV (PVEC,HANDLE)

!         add array and distributed_vector

REAL(KIND=JPRB),                      INTENT(IN) :: PVEC(:)
TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE
REAL(KIND=JPRB), DIMENSION(HANDLE%LOCAL_START:HANDLE%LOCAL_END) ::ADD_AR_DV

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:ADD_AR_DV',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP)&
     &CALL ABOR1 ('error: add unallocated distributed_vector')

IF (SIZE(PVEC) == SIZE(HANDLE%LOCAL)) THEN
  ADD_AR_DV = PVEC(:) + HANDLE%LOCAL(:)
ELSE IF (SIZE(PVEC) == HANDLE%GLOBAL_LENGTH) THEN
  ADD_AR_DV =PVEC(HANDLE%LOCAL_START:HANDLE%LOCAL_END)+HANDLE%LOCAL(:)
ELSE
  CALL ABOR1 ('error: distributed_vector size mismatch')
ENDIF

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:ADD_AR_DV',1,ZHOOK_HANDLE)
END FUNCTION ADD_AR_DV

FUNCTION SUBTRACT_AR_DV (PVEC,HANDLE)

!         subtract array and distributed_vector

REAL(KIND=JPRB),                      INTENT(IN) :: PVEC(:)
TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE
REAL(KIND=JPRB), DIMENSION(HANDLE%LOCAL_START:HANDLE%LOCAL_END) ::SUBTRACT_AR_DV

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:SUBTRACT_AR_DV',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP)&
     &CALL ABOR1 ('error: subtract unallocated distributed_vector')

IF (SIZE(PVEC) == SIZE(HANDLE%LOCAL)) THEN
  SUBTRACT_AR_DV = PVEC(:) - HANDLE%LOCAL(:)
ELSE IF (SIZE(PVEC) == HANDLE%GLOBAL_LENGTH) THEN
  SUBTRACT_AR_DV =&
   &PVEC(HANDLE%LOCAL_START:HANDLE%LOCAL_END)-HANDLE%LOCAL(:)
ELSE
  CALL ABOR1 ('error: distributed_vector size mismatch')
ENDIF

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:SUBTRACT_AR_DV',1,ZHOOK_HANDLE)
END FUNCTION SUBTRACT_AR_DV

FUNCTION NEGATE_DV (HANDLE)

!         negate a distributed_vector

TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE
REAL(KIND=JPRB), DIMENSION(HANDLE%LOCAL_START:HANDLE%LOCAL_END) ::NEGATE_DV

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:NEGATE_DV',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP)&
     &CALL ABOR1 ('error: negate unallocated distributed_vector')

NEGATE_DV =  -HANDLE%LOCAL(:)

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:NEGATE_DV',1,ZHOOK_HANDLE)
END FUNCTION NEGATE_DV

SUBROUTINE ASSIGN_DV_DV (HANDLE1,HANDLE2)

!         copy one distributed_vector to another

TYPE (DISTRIBUTED_VECTOR), INTENT(IN)    :: HANDLE2
TYPE (DISTRIBUTED_VECTOR), INTENT(INOUT) :: HANDLE1

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:ASSIGN_DV_DV',0,ZHOOK_HANDLE)
IF (HANDLE1%MSETUP /= JPSETUP)&
     &CALL ABOR1 ('error: store to unallocated distributed_vector')

IF (HANDLE1%MSETUP /= JPSETUP)&
     &CALL ABOR1('error: copy from unallocated distributed_vector')

IF (HANDLE1%GLOBAL_LENGTH == HANDLE2%GLOBAL_LENGTH) THEN
  HANDLE1%LOCAL(:) = HANDLE2%LOCAL(:)
ELSE
  CALL ABOR1 ('error: distributed_vector size mismatch')
ENDIF

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:ASSIGN_DV_DV',1,ZHOOK_HANDLE)
END SUBROUTINE ASSIGN_DV_DV

FUNCTION MULTIPLY_DV_DV (HANDLE1,HANDLE2)

!         multiply two distributed_vectors

TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE2
TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE1
REAL(KIND=JPRB), DIMENSION(HANDLE1%LOCAL_START:HANDLE1%LOCAL_END) ::MULTIPLY_DV_DV

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:MULTIPLY_DV_DV',0,ZHOOK_HANDLE)
IF (HANDLE1%MSETUP /= JPSETUP .OR. HANDLE2%MSETUP /= JPSETUP     )&
     &CALL ABOR1 ('error: multiply unallocated distributed_vector')

IF (HANDLE1%GLOBAL_LENGTH == HANDLE2%GLOBAL_LENGTH) THEN
  MULTIPLY_DV_DV = HANDLE1%LOCAL(:) * HANDLE2%LOCAL(:)
ELSE
  CALL ABOR1 ('error: distributed_vector size mismatch')
ENDIF

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:MULTIPLY_DV_DV',1,ZHOOK_HANDLE)
END FUNCTION MULTIPLY_DV_DV

FUNCTION DIVIDE_DV_DV (HANDLE1,HANDLE2)

!         divide two distributed_vectors

TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE2
TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE1
REAL(KIND=JPRB), DIMENSION(HANDLE1%LOCAL_START:HANDLE1%LOCAL_END) ::DIVIDE_DV_DV

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:DIVIDE_DV_DV',0,ZHOOK_HANDLE)
IF (HANDLE1%MSETUP /= JPSETUP .OR. HANDLE2%MSETUP /= JPSETUP  )&
     &CALL ABOR1 ('error: divide unallocated distributed_vector')

IF (HANDLE1%GLOBAL_LENGTH == HANDLE2%GLOBAL_LENGTH) THEN
  DIVIDE_DV_DV = HANDLE1%LOCAL(:) / HANDLE2%LOCAL(:)
ELSE
  CALL ABOR1 ('error: distributed_vector size mismatch')
ENDIF

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:DIVIDE_DV_DV',1,ZHOOK_HANDLE)
END FUNCTION DIVIDE_DV_DV

FUNCTION POWER_DV_DV (HANDLE1,HANDLE2)

!         power two distributed_vectors

TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE2
TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE1
REAL(KIND=JPRB), DIMENSION(HANDLE1%LOCAL_START:HANDLE1%LOCAL_END) ::POWER_DV_DV

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:POWER_DV_DV',0,ZHOOK_HANDLE)
IF (HANDLE1%MSETUP /= JPSETUP .OR. HANDLE2%MSETUP /= JPSETUP     )&
     &CALL ABOR1 ('error: power unallocated distributed_vector')

IF (HANDLE1%GLOBAL_LENGTH == HANDLE2%GLOBAL_LENGTH) THEN
  POWER_DV_DV = HANDLE1%LOCAL(:) ** HANDLE2%LOCAL(:)
ELSE
  CALL ABOR1 ('error: distributed_vector size mismatch')
ENDIF

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:POWER_DV_DV',1,ZHOOK_HANDLE)
END FUNCTION POWER_DV_DV

FUNCTION ADD_DV_DV (HANDLE1,HANDLE2)

!         add two distributed_vectors

TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE2
TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE1
REAL(KIND=JPRB), DIMENSION(HANDLE1%LOCAL_START:HANDLE1%LOCAL_END) ::ADD_DV_DV

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:ADD_DV_DV',0,ZHOOK_HANDLE)
IF (HANDLE1%MSETUP /= JPSETUP .OR. HANDLE2%MSETUP /= JPSETUP   )&
     &CALL ABOR1 ('error: add unallocated distributed_vector')

IF (HANDLE1%GLOBAL_LENGTH == HANDLE2%GLOBAL_LENGTH) THEN
  ADD_DV_DV = HANDLE1%LOCAL(:) + HANDLE2%LOCAL(:)
ELSE
  CALL ABOR1 ('error: distributed_vector size mismatch')
ENDIF

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:ADD_DV_DV',1,ZHOOK_HANDLE)
END FUNCTION ADD_DV_DV

FUNCTION SUBTRACT_DV_DV (HANDLE1,HANDLE2)

!         subtract two distributed_vectors

TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE2
TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE1
REAL(KIND=JPRB), DIMENSION(HANDLE1%LOCAL_START:HANDLE1%LOCAL_END) ::SUBTRACT_DV_DV

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:SUBTRACT_DV_DV',0,ZHOOK_HANDLE)
IF (HANDLE1%MSETUP /= JPSETUP .OR. HANDLE2%MSETUP /= JPSETUP    )&
     &CALL ABOR1 ('error: subtract unallocated distributed_vector')

IF (HANDLE1%GLOBAL_LENGTH == HANDLE2%GLOBAL_LENGTH) THEN
  SUBTRACT_DV_DV = HANDLE1%LOCAL(:) - HANDLE2%LOCAL(:)
ELSE
  CALL ABOR1 ('error: distributed_vector size mismatch')
ENDIF

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:SUBTRACT_DV_DV',1,ZHOOK_HANDLE)
END FUNCTION SUBTRACT_DV_DV

SUBROUTINE ASSIGN_SCALAR_DV (HANDLE,SCALAR)

!         copy scalar to distributed_vector

REAL(KIND=JPRB),                      INTENT(IN)    :: SCALAR
TYPE (DISTRIBUTED_VECTOR), INTENT(INOUT) :: HANDLE

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:ASSIGN_SCALAR_DV',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP)&
     &CALL ABOR1 ('error: store to unallocated distributed_vector')

HANDLE%LOCAL(:) = SCALAR

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:ASSIGN_SCALAR_DV',1,ZHOOK_HANDLE)
END SUBROUTINE ASSIGN_SCALAR_DV

FUNCTION MULTIPLY_DV_SCALAR (HANDLE,SCALAR)

!         multiply scalar and distributed_vector

REAL(KIND=JPRB),                      INTENT(IN) :: SCALAR
TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE
REAL(KIND=JPRB), DIMENSION(HANDLE%LOCAL_START:HANDLE%LOCAL_END) ::&
      &MULTIPLY_DV_SCALAR

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:MULTIPLY_DV_SCALAR',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP)&
     &CALL ABOR1 ('error: multiply unallocated distributed_vector')

MULTIPLY_DV_SCALAR = HANDLE%LOCAL(:) * SCALAR

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:MULTIPLY_DV_SCALAR',1,ZHOOK_HANDLE)
END FUNCTION MULTIPLY_DV_SCALAR

FUNCTION DIVIDE_DV_SCALAR (HANDLE,SCALAR)

!         divide scalar and distributed_vector

REAL(KIND=JPRB),                      INTENT(IN) :: SCALAR
TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE
REAL(KIND=JPRB), DIMENSION(HANDLE%LOCAL_START:HANDLE%LOCAL_END) ::DIVIDE_DV_SCALAR

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:DIVIDE_DV_SCALAR',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP)&
     &CALL ABOR1 ('error: divide unallocated distributed_vector')

DIVIDE_DV_SCALAR = HANDLE%LOCAL(:) / SCALAR

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:DIVIDE_DV_SCALAR',1,ZHOOK_HANDLE)
END FUNCTION DIVIDE_DV_SCALAR

FUNCTION POWER_DV_SCALAR (HANDLE,SCALAR)

!         power scalar and distributed_vector

REAL(KIND=JPRB),                      INTENT(IN) :: SCALAR
TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE
REAL(KIND=JPRB), DIMENSION(HANDLE%LOCAL_START:HANDLE%LOCAL_END) ::POWER_DV_SCALAR

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:POWER_DV_SCALAR',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP)&
     &CALL ABOR1 ('error: power unallocated distributed_vector')

POWER_DV_SCALAR = HANDLE%LOCAL(:) ** SCALAR

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:POWER_DV_SCALAR',1,ZHOOK_HANDLE)
END FUNCTION POWER_DV_SCALAR

FUNCTION ADD_DV_SCALAR (HANDLE,SCALAR)

!         add scalar and distributed_vector

REAL(KIND=JPRB),                      INTENT(IN) :: SCALAR
TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE
REAL(KIND=JPRB), DIMENSION(HANDLE%LOCAL_START:HANDLE%LOCAL_END) ::ADD_DV_SCALAR

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:ADD_DV_SCALAR',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP)&
     &CALL ABOR1 ('error: add unallocated distributed_vector')

ADD_DV_SCALAR = HANDLE%LOCAL(:) + SCALAR

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:ADD_DV_SCALAR',1,ZHOOK_HANDLE)
END FUNCTION ADD_DV_SCALAR

FUNCTION SUBTRACT_DV_SCALAR (HANDLE,SCALAR)

!         subtract scalar and distributed_vector

REAL(KIND=JPRB),                      INTENT(IN) :: SCALAR
TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE
REAL(KIND=JPRB), DIMENSION(HANDLE%LOCAL_START:HANDLE%LOCAL_END) ::&
      &SUBTRACT_DV_SCALAR

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:SUBTRACT_DV_SCALAR',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP)&
     &CALL ABOR1 ('error: subtract unallocated distributed_vector')

SUBTRACT_DV_SCALAR = HANDLE%LOCAL(:) - SCALAR

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:SUBTRACT_DV_SCALAR',1,ZHOOK_HANDLE)
END FUNCTION SUBTRACT_DV_SCALAR

FUNCTION MULTIPLY_SCALAR_DV (SCALAR,HANDLE)

!         multiply scalar and distributed_vector

REAL(KIND=JPRB),                      INTENT(IN) :: SCALAR
TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE
REAL(KIND=JPRB), DIMENSION(HANDLE%LOCAL_START:HANDLE%LOCAL_END) ::&
      &MULTIPLY_SCALAR_DV

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:MULTIPLY_SCALAR_DV',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP)&
     &CALL ABOR1 ('error: multiply unallocated distributed_vector')

MULTIPLY_SCALAR_DV = SCALAR * HANDLE%LOCAL(:)

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:MULTIPLY_SCALAR_DV',1,ZHOOK_HANDLE)
END FUNCTION MULTIPLY_SCALAR_DV

FUNCTION DIVIDE_SCALAR_DV (SCALAR,HANDLE)

!         divide scalar and distributed_vector

REAL(KIND=JPRB),                      INTENT(IN) :: SCALAR
TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE
REAL(KIND=JPRB), DIMENSION(HANDLE%LOCAL_START:HANDLE%LOCAL_END) ::DIVIDE_SCALAR_DV

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:DIVIDE_SCALAR_DV',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP)&
     &CALL ABOR1 ('error: divide unallocated distributed_vector')

DIVIDE_SCALAR_DV = SCALAR / HANDLE%LOCAL(:)

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:DIVIDE_SCALAR_DV',1,ZHOOK_HANDLE)
END FUNCTION DIVIDE_SCALAR_DV

FUNCTION POWER_SCALAR_DV (SCALAR,HANDLE)

!         power scalar and distributed_vector

REAL(KIND=JPRB),                      INTENT(IN) :: SCALAR
TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE
REAL(KIND=JPRB), DIMENSION(HANDLE%LOCAL_START:HANDLE%LOCAL_END) ::POWER_SCALAR_DV

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:POWER_SCALAR_DV',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP)&
     &CALL ABOR1 ('error: power unallocated distributed_vector')

POWER_SCALAR_DV = SCALAR ** HANDLE%LOCAL(:)

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:POWER_SCALAR_DV',1,ZHOOK_HANDLE)
END FUNCTION POWER_SCALAR_DV

FUNCTION ADD_SCALAR_DV (SCALAR,HANDLE)

!         add scalar and distributed_vector

REAL(KIND=JPRB),                      INTENT(IN) :: SCALAR
TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE
REAL(KIND=JPRB), DIMENSION(HANDLE%LOCAL_START:HANDLE%LOCAL_END) ::ADD_SCALAR_DV

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:ADD_SCALAR_DV',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP)&
     &CALL ABOR1 ('error: add unallocated distributed_vector')

ADD_SCALAR_DV = SCALAR + HANDLE%LOCAL(:)

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:ADD_SCALAR_DV',1,ZHOOK_HANDLE)
END FUNCTION ADD_SCALAR_DV

FUNCTION SUBTRACT_SCALAR_DV (SCALAR,HANDLE)

!         subtract scalar and distributed_vector

REAL(KIND=JPRB),                      INTENT(IN) :: SCALAR
TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE
REAL(KIND=JPRB), DIMENSION(HANDLE%LOCAL_START:HANDLE%LOCAL_END) ::&
      &SUBTRACT_SCALAR_DV

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:SUBTRACT_SCALAR_DV',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP)&
     &CALL ABOR1 ('error: subtract unallocated distributed_vector')

SUBTRACT_SCALAR_DV = SCALAR - HANDLE%LOCAL(:)

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:SUBTRACT_SCALAR_DV',1,ZHOOK_HANDLE)
END FUNCTION SUBTRACT_SCALAR_DV

SUBROUTINE ASSIGN_DV_AR (PVEC,HANDLE)
TYPE (DISTRIBUTED_VECTOR), INTENT(IN)    :: HANDLE
REAL(KIND=JPRB),                      INTENT(OUT)   :: PVEC(:)

!         copy a distributed_vector to array

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:ASSIGN_DV_AR',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP)&
     &CALL ABOR1('error: copy from unallocated distributed_vector')

IF (SIZE(PVEC) == SIZE(HANDLE%LOCAL)) THEN
  PVEC(:) = HANDLE%LOCAL(:)
ELSE IF (SIZE(PVEC) == HANDLE%GLOBAL_LENGTH) THEN
  PVEC(:) = DVSECTION (HANDLE,1,HANDLE%GLOBAL_LENGTH)
ELSE
  CALL ABOR1 ('error: distributed_vector size mismatch')
ENDIF

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:ASSIGN_DV_AR',1,ZHOOK_HANDLE)
END SUBROUTINE ASSIGN_DV_AR

FUNCTION DVSECTION (HANDLE,KSTART,KEND)

!         copy a section of a distributed_vector to array

INTEGER(KIND=JPIM),                 INTENT(IN)    :: KSTART,KEND
TYPE (DISTRIBUTED_VECTOR), INTENT(IN)    :: HANDLE
REAL(KIND=JPRB), DIMENSION(KSTART:KEND)           :: DVSECTION

INTEGER(KIND=JPIM) :: IRECV_COUNTS(NPROC)
INTEGER(KIND=JPIM) :: ISTART,IEND,JROC

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:DVSECTION',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP)&
     &CALL ABOR1('error: copy from unallocated distributed_vector')

!         work out which bits of the vector to recieve from whom

DO JROC=1,NPROC
  ISTART = MAX(KSTART,JSTART(JROC,HANDLE%GLOBAL_LENGTH))
  IEND   = MIN(KEND  ,JEND  (JROC,HANDLE%GLOBAL_LENGTH))
  IRECV_COUNTS(JROC) = MAX(0,IEND+1-ISTART)
ENDDO

ISTART = MAX(KSTART,HANDLE%LOCAL_START)
IEND   = MIN(KEND  ,HANDLE%LOCAL_END  )

!         send and recieve bits of the vector and concatenate into dvsection

CALL GSTATS(651,0)
CALL MPL_ALLGATHERV(HANDLE%LOCAL(ISTART:IEND),DVSECTION,IRECV_COUNTS,&
 &CDSTRING='Y_D_V dvsection:')
CALL GSTATS(651,1)

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:DVSECTION',1,ZHOOK_HANDLE)
END FUNCTION DVSECTION

FUNCTION MULTIPLY_DV_AR (HANDLE,PVEC)

!         multiply distributed_vector and array

TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE
REAL(KIND=JPRB),                      INTENT(IN) :: PVEC(:)
REAL(KIND=JPRB), DIMENSION(HANDLE%LOCAL_START:HANDLE%LOCAL_END) ::MULTIPLY_DV_AR

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:MULTIPLY_DV_AR',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP)&
     &CALL ABOR1 ('error: multiply unallocated distributed_vector')

IF (SIZE(PVEC) == SIZE(HANDLE%LOCAL)) THEN
  MULTIPLY_DV_AR = HANDLE%LOCAL(:) * PVEC(:)
ELSE IF (SIZE(PVEC) == HANDLE%GLOBAL_LENGTH) THEN
  MULTIPLY_DV_AR =&
   &HANDLE%LOCAL(:)*PVEC(HANDLE%LOCAL_START:HANDLE%LOCAL_END)
ELSE
  CALL ABOR1 ('error: distributed_vector size mismatch')
ENDIF

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:MULTIPLY_DV_AR',1,ZHOOK_HANDLE)
END FUNCTION MULTIPLY_DV_AR

FUNCTION DIVIDE_DV_AR (HANDLE,PVEC)

!         divide distributed_vector and array

TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE
REAL(KIND=JPRB),                      INTENT(IN) :: PVEC(:)
REAL(KIND=JPRB), DIMENSION(HANDLE%LOCAL_START:HANDLE%LOCAL_END) ::DIVIDE_DV_AR

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:DIVIDE_DV_AR',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP)&
     &CALL ABOR1 ('error: divide unallocated distributed_vector')

IF (SIZE(PVEC) == SIZE(HANDLE%LOCAL)) THEN
  DIVIDE_DV_AR = HANDLE%LOCAL(:) / PVEC(:)
ELSE IF (SIZE(PVEC) == HANDLE%GLOBAL_LENGTH) THEN
  DIVIDE_DV_AR =HANDLE%LOCAL(:)/PVEC(HANDLE%LOCAL_START:HANDLE%LOCAL_END)
ELSE
  CALL ABOR1 ('error: distributed_vector size mismatch')
ENDIF

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:DIVIDE_DV_AR',1,ZHOOK_HANDLE)
END FUNCTION DIVIDE_DV_AR

FUNCTION POWER_DV_AR (HANDLE,PVEC)

!         power distributed_vector and array

TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE
REAL(KIND=JPRB),                      INTENT(IN) :: PVEC(:)
REAL(KIND=JPRB), DIMENSION(HANDLE%LOCAL_START:HANDLE%LOCAL_END) ::POWER_DV_AR

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:POWER_DV_AR',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP)&
     &CALL ABOR1 ('error: power unallocated distributed_vector')

IF (SIZE(PVEC) == SIZE(HANDLE%LOCAL)) THEN
  POWER_DV_AR = HANDLE%LOCAL(:) ** PVEC(:)
ELSE IF (SIZE(PVEC) == HANDLE%GLOBAL_LENGTH) THEN
  POWER_DV_AR =HANDLE%LOCAL(:)**PVEC(HANDLE%LOCAL_START:HANDLE%LOCAL_END)
ELSE
  CALL ABOR1 ('error: distributed_vector size mismatch')
ENDIF

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:POWER_DV_AR',1,ZHOOK_HANDLE)
END FUNCTION POWER_DV_AR

FUNCTION ADD_DV_AR (HANDLE,PVEC)

!         add distributed_vector and array

TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE
REAL(KIND=JPRB),                      INTENT(IN) :: PVEC(:)
REAL(KIND=JPRB), DIMENSION(HANDLE%LOCAL_START:HANDLE%LOCAL_END) ::ADD_DV_AR

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:ADD_DV_AR',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP)&
     &CALL ABOR1 ('error: add unallocated distributed_vector')

IF (SIZE(PVEC) == SIZE(HANDLE%LOCAL)) THEN
  ADD_DV_AR = HANDLE%LOCAL(:) + PVEC(:)
ELSE IF (SIZE(PVEC) == HANDLE%GLOBAL_LENGTH) THEN
  ADD_DV_AR =HANDLE%LOCAL(:)+PVEC(HANDLE%LOCAL_START:HANDLE%LOCAL_END)
ELSE
  CALL ABOR1 ('error: distributed_vector size mismatch')
ENDIF

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:ADD_DV_AR',1,ZHOOK_HANDLE)
END FUNCTION ADD_DV_AR

FUNCTION SUBTRACT_DV_AR (HANDLE,PVEC)

!         subtract distributed_vector and array

TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE
REAL(KIND=JPRB),                      INTENT(IN) :: PVEC(:)
REAL(KIND=JPRB), DIMENSION(HANDLE%LOCAL_START:HANDLE%LOCAL_END) ::SUBTRACT_DV_AR

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:SUBTRACT_DV_AR',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP)&
     &CALL ABOR1 ('error: subtract unallocated distributed_vector')

IF (SIZE(PVEC) == SIZE(HANDLE%LOCAL)) THEN
  SUBTRACT_DV_AR = HANDLE%LOCAL(:) - PVEC(:)
ELSE IF (SIZE(PVEC) == HANDLE%GLOBAL_LENGTH) THEN
  SUBTRACT_DV_AR =&
   &HANDLE%LOCAL(:)-PVEC(HANDLE%LOCAL_START:HANDLE%LOCAL_END)
ELSE
  CALL ABOR1 ('error: distributed_vector size mismatch')
ENDIF

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:SUBTRACT_DV_AR',1,ZHOOK_HANDLE)
END FUNCTION SUBTRACT_DV_AR

REAL(KIND=JPRB) FUNCTION DOT_PRODUCT_HELPER (PVEC1,PVEC2,MYSTART,MYEND,KLEN,NCHNKS)
REAL(KIND=JPRB),    INTENT(IN), DIMENSION(:) :: PVEC1,PVEC2
INTEGER(KIND=JPIM), INTENT(IN)  :: MYSTART,MYEND,KLEN,NCHNKS

INTEGER(KIND=JPIM) :: J,ISTART,IEND,JROC,IERR,IMSGLEN,&
            &ICHNK1,ICHNK2,I2,IPROCS,JJ,ICHNK
REAL(KIND=JPRB), DIMENSION(NCHNKS) :: PARTIAL,ZBUF
INTEGER(KIND=JPIM) :: IRECVCOUNTS(NPROC)


!   calculate the partial dot products for the local chunks


REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:DOT_PRODUCT_HELPER',0,ZHOOK_HANDLE)
CALL GSTATS(1170,0)
!$OMP PARALLEL DO SCHEDULE(DYNAMIC,1) PRIVATE(j,ichnk,i2,jj)
DO J=1,MYEND-MYSTART+1,NDV_CHUNK_SIZE
  ICHNK=(J-1)/NDV_CHUNK_SIZE+1
  I2=MIN(J-1+NDV_CHUNK_SIZE,MYEND-MYSTART+1)
  ZBUF(ICHNK) = 0.0_JPRB
  DO JJ=J,I2
    ZBUF(ICHNK)=ZBUF(ICHNK)+PVEC1(JJ)*PVEC2(JJ)
  ENDDO
ENDDO
!$OMP END PARALLEL DO
CALL GSTATS(1170,1)


IF(NPROC > 1) THEN  
  DO JROC=1,NPROC 
    ISTART = JSTART (JROC,KLEN)
    IEND   = JEND   (JROC,KLEN)
    ICHNK1 = 1+(ISTART-1)/NDV_CHUNK_SIZE
    ICHNK2 = (IEND-1+NDV_CHUNK_SIZE)/NDV_CHUNK_SIZE
    IRECVCOUNTS(JROC) = ICHNK2-ICHNK1+1
  ENDDO
  ICHNK=IRECVCOUNTS(MYPROC)
  CALL GSTATS(652,0)
  CALL MPL_ALLGATHERV(ZBUF(1:ICHNK),PARTIAL,IRECVCOUNTS,&
   & CDSTRING='DISTRIBUTED VECTOR(DOT_PRODUCT):')
  CALL GSTATS(652,1)
ELSE
  PARTIAL(:) = ZBUF(:)
ENDIF

!   calculate the full dot product

DOT_PRODUCT_HELPER = SUM (PARTIAL)

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:DOT_PRODUCT_HELPER',1,ZHOOK_HANDLE)
END FUNCTION DOT_PRODUCT_HELPER

REAL(KIND=JPRB) FUNCTION DOT_PRODUCT_DV_DV (HANDLE1,HANDLE2)
TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE1,HANDLE2

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:DOT_PRODUCT_DV_DV',0,ZHOOK_HANDLE)
IF (HANDLE1%MSETUP /= JPSETUP .OR. HANDLE2%MSETUP /= JPSETUP     )&
 & CALL ABOR1('error: dot_product with unallocated distributed_vector')

IF (HANDLE1%GLOBAL_LENGTH  /=  HANDLE2%GLOBAL_LENGTH)&
 &CALL ABOR1 ('error: dot_product different length distributed_vectors')

DOT_PRODUCT_DV_DV =&
      &DOT_PRODUCT_HELPER (HANDLE1%LOCAL,HANDLE2%LOCAL,&
                          &HANDLE1%LOCAL_START,HANDLE1%LOCAL_END,&
                          &HANDLE1%GLOBAL_LENGTH,HANDLE1%NCHNKS)
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:DOT_PRODUCT_DV_DV',1,ZHOOK_HANDLE)
END FUNCTION  DOT_PRODUCT_DV_DV

REAL(KIND=JPRB) FUNCTION DOT_PRODUCT_AR_DV (PVEC,HANDLE2)
REAL(KIND=JPRB),                      INTENT(IN) :: PVEC(:)
TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE2

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:DOT_PRODUCT_AR_DV',0,ZHOOK_HANDLE)
IF (HANDLE2%MSETUP /= JPSETUP     ) CALL ABOR1 &
 &('error: dot_product with unallocated distributed_vector')

IF (SIZE(PVEC)  ==  SIZE(HANDLE2%LOCAL)) THEN
  DOT_PRODUCT_AR_DV =&
   &DOT_PRODUCT_HELPER (PVEC,HANDLE2%LOCAL,&
   &HANDLE2%LOCAL_START,HANDLE2%LOCAL_END,&
   &HANDLE2%GLOBAL_LENGTH,HANDLE2%NCHNKS)
ELSEIF (SIZE(PVEC)  ==  HANDLE2%GLOBAL_LENGTH) THEN
  DOT_PRODUCT_AR_DV =&
   &DOT_PRODUCT_HELPER (PVEC(HANDLE2%LOCAL_START:&
   &HANDLE2%LOCAL_END),HANDLE2%LOCAL,&
   &HANDLE2%LOCAL_START,HANDLE2%LOCAL_END,&
   &HANDLE2%GLOBAL_LENGTH,HANDLE2%NCHNKS)
ELSE
  CALL ABOR1('error: dot_product different length distributed_vectors')
ENDIF

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:DOT_PRODUCT_AR_DV',1,ZHOOK_HANDLE)
END FUNCTION DOT_PRODUCT_AR_DV

REAL(KIND=JPRB) FUNCTION DOT_PRODUCT_DV_AR (HANDLE1,PVEC)
TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE1
REAL(KIND=JPRB),                    INTENT(IN) :: PVEC(:)

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:DOT_PRODUCT_DV_AR',0,ZHOOK_HANDLE)
IF (HANDLE1%MSETUP /= JPSETUP     ) CALL ABOR1 &
 &('error: dot_product with unallocated distributed_vector')

IF (SIZE(HANDLE1%LOCAL)  ==  SIZE(PVEC)) THEN
  DOT_PRODUCT_DV_AR =&
   &DOT_PRODUCT_HELPER (HANDLE1%LOCAL,PVEC,&
   &HANDLE1%LOCAL_START,HANDLE1%LOCAL_END,&
   &HANDLE1%GLOBAL_LENGTH,HANDLE1%NCHNKS)
ELSE IF (HANDLE1%GLOBAL_LENGTH  ==  SIZE(PVEC)) THEN
  DOT_PRODUCT_DV_AR =&
   &DOT_PRODUCT_HELPER (HANDLE1%LOCAL,&
   &PVEC(HANDLE1%LOCAL_START:&
   &HANDLE1%LOCAL_END),&
   &HANDLE1%LOCAL_START,HANDLE1%LOCAL_END,&
   &HANDLE1%GLOBAL_LENGTH,HANDLE1%NCHNKS)
ELSE
  CALL ABOR1('error: dot_product different length  &
   &distributed_vectors')
ENDIF

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:DOT_PRODUCT_DV_AR',1,ZHOOK_HANDLE)
END FUNCTION DOT_PRODUCT_DV_AR

REAL(KIND=JPRB) FUNCTION SUM_HELPER (PVEC,MYSTART,MYEND,KLEN,NCHNKS)
REAL(KIND=JPRB),    INTENT(IN), DIMENSION(:) :: PVEC
INTEGER(KIND=JPIM), INTENT(IN)  :: MYSTART,MYEND,KLEN,NCHNKS

INTEGER(KIND=JPIM) :: J,ISTART,IEND,ITAG,JROC,IERR,&
 &ICHNK1,ICHNK2,I2,IPROCS,IROC,JJ,ISENDR
REAL(KIND=JPRB), DIMENSION(NCHNKS) :: PARTIAL,ZBUF

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:SUM_HELPER',0,ZHOOK_HANDLE)
ITAG    = MT_DISTRIBUTED_VECTOR

!   calculate the partial sums for the local chunks

IF (MYEND >= MYSTART) THEN
  ICHNK1 = 1+(MYSTART-1)/NDV_CHUNK_SIZE
  ICHNK2 = ICHNK1-1
  
  DO J=1,MYEND-MYSTART+1,NDV_CHUNK_SIZE
    I2=MIN(J-1+NDV_CHUNK_SIZE,MYEND-MYSTART+1)
    ICHNK2 = ICHNK2+1
    !              partial(ichnk2)= SUM (pvec(j:i2))
    PARTIAL(ICHNK2)=0.0_JPRB
    DO JJ=J,I2
      PARTIAL(ICHNK2)=PARTIAL(ICHNK2)+PVEC(JJ)
    ENDDO
    
  ENDDO

!   broadcast the partial dot products for the local chunks

  DO JROC=0,NPROC-2
    IROC=MOD(MYPROC+JROC,NPROC)+1
    CALL MPL_SEND (PARTIAL(ICHNK1:ICHNK2),KDEST=NPRCIDS(IROC), &
     &   KTAG=ITAG,CDSTRING='DISTRIBUTED VECTOR:')
  ENDDO
ENDIF

!   gather the partial dot products from the other PEs


IF (MYEND >= MYSTART) THEN
  IPROCS=MIN(NCHNKS,NPROC)-1
ELSE
  IPROCS=MIN(NCHNKS,NPROC)
ENDIF

DO JROC=1,IPROCS
  CALL MPL_RECV(ZBUF(1:NCHNKS),KFROM=ISENDR, &
   & KTAG=ITAG,CDSTRING='DISTRIBUTED VECTOR:')
  ISTART = JSTART (ISENDR,KLEN)
  IEND   = JEND   (ISENDR,KLEN)
  ICHNK1 = 1+(ISTART-1)/NDV_CHUNK_SIZE
  ICHNK2 = (IEND-1+NDV_CHUNK_SIZE)/NDV_CHUNK_SIZE
  PARTIAL(ICHNK1:ICHNK2)=ZBUF(1:ICHNK2+1-ICHNK1)
ENDDO

!   calculate the full sum

SUM_HELPER = SUM (PARTIAL)

!   synchronize
CALL MPL_BARRIER (CDSTRING='DISTRIBUTED VECTOR SUM:')

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:SUM_HELPER',1,ZHOOK_HANDLE)
END FUNCTION SUM_HELPER

REAL(KIND=JPRB) FUNCTION SUM_DV (HANDLE)
TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:SUM_DV',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP) CALL ABOR1 &
 &('error: sum with unallocated distributed_vector')


SUM_DV =&
 &SUM_HELPER (HANDLE%LOCAL,&
 &HANDLE%LOCAL_START,HANDLE%LOCAL_END,&
 &HANDLE%GLOBAL_LENGTH,HANDLE%NCHNKS)

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:SUM_DV',1,ZHOOK_HANDLE)
END FUNCTION  SUM_DV

REAL(KIND=JPRB) FUNCTION MAXVAL_HELPER (PVEC,MYSTART,MYEND,KLEN,NCHNKS)
REAL(KIND=JPRB),    INTENT(IN), DIMENSION(:) :: PVEC
INTEGER(KIND=JPIM), INTENT(IN)  :: MYSTART,MYEND,KLEN,NCHNKS

INTEGER(KIND=JPIM) :: J,ISTART,IEND,ITAG,JROC,IERR,IMSGLEN,ISENDR,ITAGR,&
 &ICHNK1,ICHNK2,I2,IPROCS,IROC,JJ
REAL(KIND=JPRB), DIMENSION(NCHNKS) :: PARTIAL,ZBUF

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:MAXVAL_HELPER',0,ZHOOK_HANDLE)
ITAG    = MT_DISTRIBUTED_VECTOR

!   calculate the partial maxvals for the local chunks

IF (MYEND >= MYSTART) THEN
  ICHNK1 = 1+(MYSTART-1)/NDV_CHUNK_SIZE
  ICHNK2 = ICHNK1-1

  DO J=1,MYEND-MYSTART+1,NDV_CHUNK_SIZE
    I2=MIN(J-1+NDV_CHUNK_SIZE,MYEND-MYSTART+1)
    ICHNK2 = ICHNK2+1
    PARTIAL(ICHNK2)= MAXVAL (PVEC(J:I2))
  ENDDO

!   broadcast the partial max values for the local chunks


  DO JROC=0,NPROC-2
    IROC=MOD(MYPROC+JROC,NPROC)+1
    CALL MPL_SEND (PARTIAL(ICHNK1:ICHNK2),KDEST=NPRCIDS(IROC), &
     &   KTAG=ITAG,CDSTRING='DISTRIBUTED VECTOR:')
  ENDDO
ENDIF

!   gather the partial max values from the other PEs


IF (MYEND >= MYSTART) THEN
  IPROCS=MIN(NCHNKS,NPROC)-1
ELSE
  IPROCS=MIN(NCHNKS,NPROC)
ENDIF

DO JROC=1,IPROCS
  CALL MPL_RECV(ZBUF(1:NCHNKS),KFROM=ISENDR, &
   & KTAG=ITAG,CDSTRING='DISTRIBUTED VECTOR:')
  ISTART = JSTART (ISENDR,KLEN)
  IEND   = JEND   (ISENDR,KLEN)
  ICHNK1 = 1+(ISTART-1)/NDV_CHUNK_SIZE
  ICHNK2 = (IEND-1+NDV_CHUNK_SIZE)/NDV_CHUNK_SIZE
  PARTIAL(ICHNK1:ICHNK2)=ZBUF(1:ICHNK2+1-ICHNK1)
ENDDO

!   calculate the full max value

MAXVAL_HELPER = MAXVAL (PARTIAL)

!   synchronize
CALL MPL_BARRIER (CDSTRING='MAXVAL:')

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:MAXVAL_HELPER',1,ZHOOK_HANDLE)
END FUNCTION MAXVAL_HELPER

REAL(KIND=JPRB) FUNCTION MAXVAL_DV (HANDLE)
TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:MAXVAL_DV',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP) CALL ABOR1 &
 &('error: maxval with unallocated distributed_vector')


MAXVAL_DV =&
 &MAXVAL_HELPER (HANDLE%LOCAL,&
 &HANDLE%LOCAL_START,HANDLE%LOCAL_END,&
 &HANDLE%GLOBAL_LENGTH,HANDLE%NCHNKS)

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:MAXVAL_DV',1,ZHOOK_HANDLE)
END FUNCTION  MAXVAL_DV

FUNCTION SQRT_DV (HANDLE)

!         add two distributed_vectors

TYPE (DISTRIBUTED_VECTOR), INTENT(IN) :: HANDLE
REAL(KIND=JPRB), DIMENSION(HANDLE%LOCAL_START:HANDLE%LOCAL_END) :: SQRT_DV

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:SQRT_DV',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP .OR. HANDLE%MSETUP /= JPSETUP   )&
     &CALL ABOR1 ('error: sqrt unallocated distributed_vector')

SQRT_DV = SQRT(HANDLE%LOCAL(:))

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:SQRT_DV',1,ZHOOK_HANDLE)
END FUNCTION SQRT_DV


SUBROUTINE SCATTER_VECTOR_DV (HANDLE,KROOT,PVEC)

!         distribute vector

TYPE (DISTRIBUTED_VECTOR), INTENT(OUT)  :: HANDLE
INTEGER(KIND=JPIM), INTENT(IN)                   :: KROOT
REAL(KIND=JPRB),OPTIONAL,           INTENT(IN)   :: PVEC(:)
INTEGER(KIND=JPIM) :: ITAG,JROC,ISTART,IEND,IERR,IMSGLEN,ISENDR,ITAGR

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:SCATTER_VECTOR_DV',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP)&
 &CALL ABOR1 &
 &('scatter_vector: copy to unallocated distributed_vector')

ITAG = MT_DISTRIBUTED_VECTOR

IF(KROOT == MYPROC) THEN 
  IF(.NOT. PRESENT(PVEC)) &
   & CALL ABOR1 ('scatter_vector: pvec missing from kroot')
  IF (SIZE(PVEC) /= HANDLE%GLOBAL_LENGTH)&
   &CALL ABOR1 &
   &('scatter_vector: unequal size')

!         broadcast the local part to the other PEs


  DO JROC=1,NPROC
    IF (JROC /= MYPROC) THEN
      ISTART=JSTART(JROC,HANDLE%GLOBAL_LENGTH)
      IEND=JEND(JROC,HANDLE%GLOBAL_LENGTH)
      IF (IEND >= ISTART) THEN
        CALL MPL_SEND (PVEC(ISTART:IEND),KDEST=NPRCIDS(JROC), &
         &   KTAG=ITAG,CDSTRING='DISTRIBUTED VECTOR:')
      ENDIF
    ENDIF
  ENDDO

!         copy the local part from pvec

  HANDLE%LOCAL(:)=PVEC(HANDLE%LOCAL_START:HANDLE%LOCAL_END)
ELSE

!         collect the local parts from the distributing PE
  
  ISTART = JSTART (MYPROC,HANDLE%GLOBAL_LENGTH)
  IEND   = JEND   (MYPROC,HANDLE%GLOBAL_LENGTH)
  IF (IEND >= ISTART) THEN
    CALL MPL_RECV(HANDLE%LOCAL(ISTART:IEND),KOUNT=IMSGLEN, &
     & KTAG=ITAG,CDSTRING='DISTRIBUTED VECTOR:')
    IF (IMSGLEN /= IEND+1-ISTART)&
     &CALL ABOR1('SCATTER_VECTOR:WRONG LENGTH IN MPL_RECV')
  ENDIF
ENDIF

CALL MPL_BARRIER (CDSTRING='SCATTER_VECTOR:')

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:SCATTER_VECTOR_DV',1,ZHOOK_HANDLE)
END SUBROUTINE SCATTER_VECTOR_DV

SUBROUTINE SCATTER_VECTOR_AR (PARRAY,KROOT,PVEC)

!         distribute vector

REAL(KIND=JPRB), INTENT(OUT)             :: PARRAY(:)
INTEGER(KIND=JPIM), INTENT(IN)           :: KROOT
REAL(KIND=JPRB),OPTIONAL, INTENT(IN)     :: PVEC(:)
INTEGER(KIND=JPIM) :: ITAG,ILEN,IERR


REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:SCATTER_VECTOR_AR',0,ZHOOK_HANDLE)
ITAG = MT_DISTRIBUTED_VECTOR
ILEN = SIZE(PARRAY)

IF(KROOT == MYPROC) THEN 
  IF(.NOT. PRESENT(PVEC))& 
   & CALL ABOR1 ('scatter_vector: pvec missing from kroot')
  IF (SIZE(PVEC) /= ILEN) CALL ABOR1('scatter_vector: unequal size')

!         copy  from pvec

  PARRAY(:)=PVEC(:)

ENDIF

CALL GSTATS(653,0)
CALL MPL_BROADCAST(PARRAY,ITAG,KROOT=KROOT,&
 & CDSTRING='DISTRIBUTED VECTOR (SCATTER_VECTOR):')
CALL GSTATS(653,1)

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:SCATTER_VECTOR_AR',1,ZHOOK_HANDLE)
END SUBROUTINE SCATTER_VECTOR_AR

SUBROUTINE GATHER_VECTOR (HANDLE,KROOT,PVEC)

!         distribute vector

TYPE (DISTRIBUTED_VECTOR), INTENT(IN)   :: HANDLE
INTEGER(KIND=JPIM), INTENT(IN)                   :: KROOT
REAL(KIND=JPRB),OPTIONAL,           INTENT(OUT)  :: PVEC(:)
INTEGER(KIND=JPIM) :: ITAG,JROC,ISTART,IEND,IST,IEN
INTEGER(KIND=JPIM) :: IRECVCOUNTS(NPROC)

REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:GATHER_VECTOR',0,ZHOOK_HANDLE)
IF (HANDLE%MSETUP /= JPSETUP)&
 &CALL ABOR1('gather_vector: copy to unallocated distributed_vector')

DO JROC=1,NPROC
  IST=JSTART(JROC,HANDLE%GLOBAL_LENGTH)
  IEN=JEND(JROC,HANDLE%GLOBAL_LENGTH)
  IRECVCOUNTS(JROC) = IEN-IST+1
ENDDO

CALL GSTATS(654,0)
IF(KROOT == MYPROC) THEN 
  IF(.NOT. PRESENT(PVEC)) &
   & CALL ABOR1('gather_vector: pvec missing from kroot')
  IF (SIZE(PVEC) /= HANDLE%GLOBAL_LENGTH)&
   &CALL ABOR1('gather_vector: unequal size')
  
!         collect the local parts from all other PEs
  
  CALL MPL_GATHERV(HANDLE%LOCAL,KROOT=KROOT,&
   & KRECVCOUNTS=IRECVCOUNTS,PRECVBUF=PVEC,&
   & CDSTRING='DISTRIBUTED VECTOR(gather_VECTOR):')
  
ELSE
  CALL MPL_GATHERV(HANDLE%LOCAL,KROOT=KROOT,&
   & KRECVCOUNTS=IRECVCOUNTS,&
   & CDSTRING='DISTRIBUTED VECTOR(gather_VECTOR):')
ENDIF
CALL GSTATS(654,1)

IF (LHOOK) CALL DR_HOOK('DISTRIBUTED_VECTORS_MIX:GATHER_VECTOR',1,ZHOOK_HANDLE)
END SUBROUTINE GATHER_VECTOR

END MODULE DISTRIBUTED_VECTORS_MIX
